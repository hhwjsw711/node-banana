---
phase: 18-api-route-tests
plan: 05
type: execute
---

<objective>
Add tests for models API route covering caching and provider aggregation.

Purpose: Test model discovery and caching logic for multi-provider support.
Output: Tests for /api/models route with mocked provider APIs and cache behavior.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Route to test:**
@src/app/api/models/route.ts

**Cache module to mock:**
@src/lib/providers/cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create models route tests for basic functionality</name>
  <files>src/app/api/models/__tests__/route.test.ts</files>
  <action>
Create tests for /api/models route core functionality:
- GET: Returns models from fal.ai when no Replicate key (fal.ai works without key)
- GET: Returns models from both providers when both keys present
- GET: Returns 400 when no providers available (Replicate needs key, fal.ai not tested)
- GET: Filters by provider query param
- GET: Filters by capabilities query param
- GET: Searches by query param
- GET: Returns cached=true when all from cache
- GET: Returns cached=false when fresh fetch

Mock @/lib/providers/cache:
```typescript
vi.mock("@/lib/providers/cache", () => ({
  getCachedModels: vi.fn(),
  setCachedModels: vi.fn(),
  getCacheKey: vi.fn((provider, search) => `${provider}:${search || ""}`),
}));
```

Mock global fetch for provider API calls:
```typescript
// Replicate models response
mockFetch.mockResolvedValueOnce({
  ok: true,
  json: () => Promise.resolve({
    results: [{ owner: "stability-ai", name: "sdxl", description: "SDXL" }],
    next: null,
  }),
});

// fal.ai models response
mockFetch.mockResolvedValueOnce({
  ok: true,
  json: () => Promise.resolve({
    models: [{
      endpoint_id: "fal-ai/flux",
      metadata: { display_name: "Flux", category: "text-to-image", description: "" },
    }],
    has_more: false,
  }),
});
```
  </action>
  <verify>npm test -- src/app/api/models/__tests__/route.test.ts --testNamePattern="basic"</verify>
  <done>Basic models route tests pass covering filtering and caching</done>
</task>

<task type="auto">
  <name>Task 2: Add models route tests for caching and error handling</name>
  <files>src/app/api/models/__tests__/route.test.ts</files>
  <action>
Add caching and error tests to existing test file:
- GET: Returns cached models when available (no fetch)
- GET: Bypasses cache when refresh=true
- GET: Client-side filters Replicate models (caches full list, filters on read)
- GET: Handles partial provider failures gracefully
- GET: Returns 500 when all providers fail
- GET: Paginates through Replicate results (max 15 pages)
- GET: Paginates through fal.ai results (max 15 pages)

Test capability inference for Replicate:
- Video keywords (video, animate, motion) → text-to-video
- Image-to-video keywords (img2vid, i2v) → image-to-video
- Image keywords → text-to-image

Test fal.ai category mapping:
- Category maps directly to ModelCapability
- Non-relevant categories are filtered out

Test sorting:
- Models sorted by provider, then by name
  </action>
  <verify>npm test -- src/app/api/models/__tests__/route.test.ts</verify>
  <done>All models route tests pass covering caching, pagination, and error handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- src/app/api/models/__tests__/route.test.ts` passes
- [ ] Cache behavior tested (hit, miss, refresh)
- [ ] Both providers tested
- [ ] Filtering and search tested
- [ ] Error handling tested
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Cache logic thoroughly tested
- Provider aggregation tested
</success_criteria>

<output>
After completion, create `.planning/phases/18-api-route-tests/18-05-SUMMARY.md`
</output>
