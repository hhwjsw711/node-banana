---
phase: 16-store-modularization
plan: 02
type: execute
---

<objective>
Extract workflow execution logic from workflowStore.ts into a dedicated execution module.

Purpose: The execution logic (~800 lines) is the largest section and most complex. Extracting it enables focused testing and cleaner separation of concerns between state management and execution orchestration.
Output: New execution module with executeWorkflow, regenerateNode, and supporting execution utilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-store-modularization/16-01-PLAN.md
@src/store/workflowStore.ts

**Dependencies from 16-01:**
- localStorage utilities extracted
- nodeDefaults module exists

**Execution Logic Analysis (~800 lines):**
The executeWorkflow and regenerateNode functions are tightly coupled to store state but can be extracted as action creators that receive state getters/setters. Key components:
- Topological sort algorithm (~30 lines)
- Node execution switch statement (~600 lines for all node types)
- API call patterns (repeated for each provider)
- Logger calls throughout
- State updates via updateNodeData
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract execution utilities</name>
  <files>src/store/execution/utils.ts</files>
  <action>
Create src/store/execution/utils.ts with reusable execution utilities:

1. Extract topologicalSort function:
   - Takes nodes and edges as input
   - Returns sorted WorkflowNode array
   - Throws on cycle detection

2. Extract buildProviderHeaders function:
   - Takes provider type and providerSettings
   - Returns headers object with API key headers
   - Consolidates the repeated header building logic from executeWorkflow/regenerateNode

3. Extract getSourceOutput helper:
   - Takes a WorkflowNode
   - Returns { type: "image" | "text" | "video", value: string | null }
   - Currently duplicated in getConnectedInputs

4. Export types:
   - ExecutionResult = { success: boolean; error?: string; data?: unknown }
   - NodeExecutionContext = { nodeId: string; get: () => StoreState; set: (partial: Partial<StoreState>) => void }

These are pure functions that don't directly depend on Zustand, making them testable.
  </action>
  <verify>npm run build succeeds, new module compiles without errors</verify>
  <done>Execution utilities extracted, types defined, build passes</done>
</task>

<task type="auto">
  <name>Task 2: Extract node executors</name>
  <files>src/store/execution/nodeExecutors.ts</files>
  <action>
Create src/store/execution/nodeExecutors.ts with individual node type executors:

1. Create executor type:
   ```typescript
   type NodeExecutor = (
     node: WorkflowNode,
     context: {
       getConnectedInputs: (nodeId: string) => ConnectedInputs;
       updateNodeData: (nodeId: string, data: Partial<WorkflowNodeData>) => void;
       get: () => WorkflowStoreState;
       set: (partial: Partial<WorkflowStoreState>) => void;
       providerSettings: ProviderSettings;
     }
   ) => Promise<{ continue: boolean; error?: string }>;
   ```

2. Extract executors for each node type:
   - executeImageInput (no-op, returns continue: true)
   - executeAnnotation
   - executePrompt (no-op)
   - executeNanoBanana (image generation)
   - executeGenerateVideo (video generation)
   - executeLlmGenerate (text generation)
   - executeSplitGrid
   - executeOutput

3. Create nodeExecutorMap:
   ```typescript
   const nodeExecutorMap: Record<NodeType, NodeExecutor> = { ... }
   ```

4. Export executeNode function that dispatches to the correct executor

This keeps the individual node logic but allows testing each executor in isolation.
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>Node executors extracted as individual functions with shared interface</done>
</task>

<task type="auto">
  <name>Task 3: Refactor executeWorkflow to use extracted modules</name>
  <files>src/store/workflowStore.ts</files>
  <action>
Update executeWorkflow in workflowStore.ts to use the extracted modules:

1. Import from execution/utils.ts:
   - topologicalSort
   - buildProviderHeaders

2. Import from execution/nodeExecutors.ts:
   - executeNode

3. Refactor executeWorkflow to use the imported utilities:
   - Replace inline topological sort with topologicalSort()
   - Replace switch statement with executeNode() calls
   - Keep the overall orchestration logic (pause handling, locked groups, logging) in the store

4. Refactor regenerateNode similarly:
   - Use buildProviderHeaders
   - Could call individual executors but for now keep inline (regenerate has slightly different flow)

5. Ensure getConnectedInputs stays in the store (it needs edge state)

The goal is to reduce executeWorkflow from ~800 lines to ~200 lines of orchestration logic.
  </action>
  <verify>npm run build succeeds, npm test passes, manual test of workflow execution works</verify>
  <done>executeWorkflow refactored to ~200 lines, uses extracted modules, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests
- [ ] executeWorkflow function reduced from ~800 to ~200 lines
- [ ] Workflow execution still works (test with a simple prompt -> generate -> output flow)
- [ ] regenerateNode still works
- [ ] Error handling preserved
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- executeWorkflow is significantly shorter and more readable
- Node execution logic is isolated and testable
- No regression in workflow execution behavior
</success_criteria>

<output>
After completion, create `.planning/phases/16-store-modularization/16-02-SUMMARY.md`
</output>
