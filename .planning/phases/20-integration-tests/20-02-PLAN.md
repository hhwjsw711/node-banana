---
phase: 20-integration-tests
plan: 02
type: execute
---

<objective>
Test end-to-end workflow execution with data flow between nodes and error handling.

Purpose: Verify that workflow execution correctly passes data between connected nodes, handles errors gracefully, and maintains proper state throughout execution.
Output: Integration tests for full workflow execution scenarios with mocked API responses.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-integration-tests/20-01-SUMMARY.md
@src/store/workflowStore.ts
@src/store/__tests__/workflowStore.integration.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflow execution data flow tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Add integration tests for workflow execution data flow:

1. **Image data flow:**
   - imageInput → nanoBanana: image reaches generate node
   - imageInput → annotation → nanoBanana: annotation output reaches generate
   - Multiple images collected in inputImages array

2. **Text data flow:**
   - prompt → nanoBanana: text reaches inputPrompt
   - prompt → llmGenerate → nanoBanana: LLM output becomes generate input
   - dynamicInputs populated from schema-mapped connections

3. **Mixed data flow:**
   - prompt + imageInput → nanoBanana: both text and images reach node
   - Correct handle mapping when node has inputSchema

4. **State updates during execution:**
   - Node status changes to "loading" during execution
   - Node status changes to "complete" on success
   - outputImage/outputText populated from API response

Mock setup:
- Mock fetch to return controlled responses
- Mock logger.startSession, logger.endSession
- Use waitFor() for async state updates
- Check node data after execution completes

Important: Focus on verifying data REACHES the node correctly via updateNodeData calls. The actual API transformation is tested in API route tests.
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with data flow tests</verify>
  <done>Data flow tests verify images and text correctly pass through node chains</done>
</task>

<task type="auto">
  <name>Task 2: Add error handling and edge case tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Add integration tests for error handling and edge cases:

1. **Missing input errors:**
   - nanoBanana without text input sets error status
   - generateVideo without model selected sets error status
   - Execution stops on error (subsequent nodes not executed)

2. **API error handling:**
   - HTTP error response sets node error status
   - Network error sets appropriate error message
   - isRunning set to false on error

3. **Workflow state management:**
   - isRunning true during execution
   - isRunning false after completion
   - currentNodeId updates as each node executes
   - currentNodeId null after completion

4. **Resume functionality:**
   - Starting from specific nodeId skips earlier nodes
   - startFromNodeId finds correct index in sorted order
   - Resuming from pausedAtNodeId works correctly

Mock fetch to return error responses for error tests. Use waitFor to check final state after async operations complete.
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with error handling tests</verify>
  <done>Error handling tests cover all error scenarios in executeWorkflow</done>
</task>

<task type="auto">
  <name>Task 3: Add connection validation integration tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Add integration tests for connection validation logic used by WorkflowCanvas:

1. **Type matching validation:**
   - image handle accepts image source only
   - text handle accepts text source only
   - video handle accepts video source only

2. **Self-connection prevention:**
   - Node cannot connect to itself

3. **Duplicate connection prevention:**
   - Same source→target connection cannot be added twice

4. **Handle type inference:**
   - isImageHandle correctly identifies image handles
   - isTextHandle correctly identifies text handles
   - Handles with schema names (image_url, prompt) work correctly

Note: The actual isValidConnection function is in WorkflowCanvas.tsx, but the helpers like isImageHandle/isTextHandle are in getConnectedInputs. Test the integration between handle identification and data extraction.

This can be tested by creating edges with various handle configurations and verifying getConnectedInputs correctly categorizes them.
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with connection validation tests</verify>
  <done>Connection validation tests verify type matching and handle identification</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test src/store/__tests__/workflowStore.integration.test.ts` passes all tests
- [ ] Tests cover data flow, error handling, and connection validation
- [ ] No TypeScript errors
- [ ] `npm run build` succeeds
- [ ] All tests from Plan 01 still pass
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Integration tests provide meaningful E2E coverage
- Phase 20 provides confidence in workflow execution correctness
</success_criteria>

<output>
After completion, create `.planning/phases/20-integration-tests/20-02-SUMMARY.md`
</output>
