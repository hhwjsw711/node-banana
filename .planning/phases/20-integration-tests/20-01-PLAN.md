---
phase: 20-integration-tests
plan: 01
type: execute
---

<objective>
Test workflowStore integration functions that handle node connections and data flow.

Purpose: Verify that getConnectedInputs correctly extracts data from connected nodes and validateWorkflow properly checks workflow integrity.
Output: Comprehensive test suite for workflowStore integration functions with full coverage of connection scenarios.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/store/workflowStore.ts
@src/store/__tests__/ (to be created)
@src/components/__tests__/WorkflowCanvas.test.tsx (existing patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workflowStore integration test file with getConnectedInputs tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Create integration tests for getConnectedInputs function covering:

1. **Basic data extraction scenarios:**
   - Image from imageInput node flows to target
   - Image from annotation node (outputImage) flows to target
   - Image from nanoBanana node (outputImage) flows to target
   - Text from prompt node flows to target
   - Text from llmGenerate node (outputText) flows to target

2. **Multiple connections:**
   - Multiple images from different sources collected in images array
   - Text takes last connected source (not array)
   - Mix of image and text connections to same node

3. **Dynamic input mapping:**
   - Handle IDs mapped to schema names when inputSchema present
   - Multiple image handles (image, image-0, image-1) map to schema names
   - Multiple text handles (text, text-0, text-1) map to schema names
   - No schema means no dynamicInputs population

4. **Edge cases:**
   - No connections returns empty images array and null text
   - Source node has null output data
   - Connection to non-existent source node

Test setup: Create a minimal Zustand store with test nodes and edges, call getConnectedInputs directly. Use vi.fn() for mocking, follow existing patterns from component tests.

Do NOT mock the entire workflowStore - use the actual implementation but with controlled test data.
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with all scenarios covered</verify>
  <done>getConnectedInputs tests cover all documented scenarios, tests pass, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Add validateWorkflow integration tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Add tests for validateWorkflow function to the same test file covering:

1. **Empty workflow:**
   - Returns invalid with "Workflow is empty" error

2. **nanoBanana node validation:**
   - Missing text input returns error
   - Text input connected returns valid
   - Image input optional (no error if missing)

3. **annotation node validation:**
   - No image connected and no sourceImage returns error
   - Image connected returns valid
   - sourceImage present (manual load) returns valid even without connection

4. **Valid workflow scenarios:**
   - Simple prompt → nanoBanana → output chain
   - Complex workflow with multiple node types
   - Workflow with groups

Use the same test setup pattern - create store with test data, call validateWorkflow.
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with validateWorkflow tests</verify>
  <done>validateWorkflow tests cover all validation scenarios documented in workflowStore.ts</done>
</task>

<task type="auto">
  <name>Task 3: Add topological sort integration tests</name>
  <files>src/store/__tests__/workflowStore.integration.test.ts</files>
  <action>
Add tests for topological sort ordering in executeWorkflow. Since executeWorkflow has side effects (API calls), these tests need careful mocking:

1. **Test setup:**
   - Mock fetch globally to intercept API calls
   - Mock logger to avoid noise
   - Use act() wrapper for state updates

2. **Execution order tests:**
   - Linear chain (A → B → C) executes in order
   - Multiple dependencies (A, B → C) executes A, B before C
   - Parallel branches merge correctly
   - Cycle detection throws error

3. **Pause edge handling:**
   - Execution stops at node with incoming pause edge
   - pausedAtNodeId is set correctly
   - Resuming from paused node skips pause check

4. **Locked group handling:**
   - Nodes in locked groups are skipped
   - Non-locked group nodes execute normally

Mock fetch to return success responses for nanoBanana/generateVideo nodes. Focus on testing execution ORDER, not API response handling (that's covered in API route tests).
  </action>
  <verify>npm test src/store/__tests__/workflowStore.integration.test.ts passes with topological sort tests</verify>
  <done>Topological sort tests verify correct execution order for various graph structures</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test src/store/__tests__/workflowStore.integration.test.ts` passes all tests
- [ ] Tests cover getConnectedInputs, validateWorkflow, and topological sort
- [ ] No TypeScript errors in test file
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Integration tests provide meaningful coverage of store functions
- Tests follow existing patterns from component tests
</success_criteria>

<output>
After completion, create `.planning/phases/20-integration-tests/20-01-SUMMARY.md`
</output>
