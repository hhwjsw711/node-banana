---
phase: 03-generate-node-refactor
plan: 03
type: execute
---

<objective>
Ensure backward compatibility for existing workflows.

Purpose: Existing saved workflows must load and execute without modification.
Output: Migration logic, working execution with both legacy and new formats.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-generate-node-refactor/03-01-SUMMARY.md
@.planning/phases/03-generate-node-refactor/03-02-SUMMARY.md
@src/store/workflowStore.ts
@src/components/nodes/GenerateImageNode.tsx

**Constraints:** Node type "nanoBanana" unchanged, legacy ModelType must work
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflow migration logic</name>
  <files>src/store/workflowStore.ts</files>
  <action>
  In workflow loading (loadWorkflow or where JSON is parsed):
  1. For nanoBanana nodes without selectedModel, derive it from legacy model field:
     ```typescript
     if (node.type === "nanoBanana" && node.data.model && !node.data.selectedModel) {
       node.data.selectedModel = {
         provider: "gemini",
         modelId: node.data.model,
         displayName: node.data.model === "nano-banana" ? "Nano Banana" : "Nano Banana Pro"
       };
     }
     ```
  2. Keep both fields synced on save for bidirectional compatibility
  </action>
  <verify>Load existing workflow file, check node has selectedModel populated</verify>
  <done>Old workflows load with selectedModel auto-populated</done>
</task>

<task type="auto">
  <name>Task 2: Update executeWorkflow for multi-provider</name>
  <files>src/store/workflowStore.ts</files>
  <action>
  In executeWorkflow nanoBanana case:
  1. Check for selectedModel
  2. If non-Gemini provider, add API key headers from providerSettings:
     ```typescript
     const headers = { "Content-Type": "application/json" };
     if (nodeData.selectedModel?.provider === "replicate") {
       const config = get().providerSettings.providers.find(p => p.id === "replicate");
       if (config?.apiKey) headers["X-Replicate-API-Key"] = config.apiKey;
     }
     // Similar for fal
     ```
  3. Include selectedModel in request body
  4. Handle GenerationOutput response format
  </action>
  <verify>Execute workflow with Gemini model</verify>
  <done>Execution works for both legacy and new model selection</done>
</task>

<task type="auto">
  <name>Task 3: Handle legacy data in GenerateImageNode UI</name>
  <files>src/components/nodes/GenerateImageNode.tsx</files>
  <action>
  1. On mount/data change: if model exists but not selectedModel, derive selectedModel
  2. Ensure dropdowns reflect correct provider/model for migrated nodes
  3. Save defaults in both formats for compatibility
  </action>
  <verify>Open workflow with old nanoBanana node, verify correct selection shown</verify>
  <done>UI correctly displays legacy nodes</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] Existing workflow loads without errors
- [ ] Legacy Gemini execution works
- [ ] New provider selection persists correctly
</verification>

<success_criteria>
- Existing workflows load and execute unchanged
- Migration auto-populates selectedModel
- Both formats work in same workflow
- Phase 3 complete
</success_criteria>

<output>
Create `.planning/phases/03-generate-node-refactor/03-03-SUMMARY.md`
</output>
