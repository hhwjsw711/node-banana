---
phase: 03-generate-node-refactor
plan: 03
type: execute
---

<objective>
Ensure backward compatibility for existing workflows containing nanoBanana nodes.

Purpose: Existing saved workflows must load and execute correctly without modification.
Output: Migration logic, verified backward compatibility, updated workflow execution.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/03-generate-node-refactor/03-01-SUMMARY.md
@.planning/phases/03-generate-node-refactor/03-02-SUMMARY.md

# Key source files:
@src/store/workflowStore.ts
@src/types/index.ts
@src/components/nodes/GenerateNode.tsx

**Tech stack available:** Zustand, workflow JSON persistence
**Established patterns:** Workflow load/save in workflowStore
**Constraining decisions:**
- Node type "nanoBanana" must remain unchanged in workflow files
- Legacy ModelType ("nano-banana", "nano-banana-pro") must still work
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration logic for loaded workflows</name>
  <files>src/store/workflowStore.ts</files>
  <action>
  1. In loadWorkflow() or where workflow JSON is parsed, add migration:
     - When loading a nanoBanana node without selectedModel field
     - Automatically set selectedModel based on legacy model field:
       ```typescript
       if (node.type === "nanoBanana" && node.data.model && !node.data.selectedModel) {
         node.data.selectedModel = {
           provider: "gemini",
           modelId: node.data.model,
           displayName: node.data.model === "nano-banana" ? "Nano Banana" : "Nano Banana Pro"
         };
       }
       ```

  2. Keep legacy model field synced for saves:
     - When selectedModel is Gemini, also update the model field
     - This ensures old versions can still read the workflow

  3. Add version field to workflow if not present:
     - Set workflowVersion in saved JSON for future migrations
     - Not strictly necessary but good practice

  WHY: Migration on load allows old workflows to work without manual editing. Syncing both fields maintains bidirectional compatibility.
  </action>
  <verify>Load an existing workflow file, check node data has both model and selectedModel</verify>
  <done>Old workflows load with selectedModel populated, new saves include both fields</done>
</task>

<task type="auto">
  <name>Task 2: Update executeWorkflow for multi-provider generation</name>
  <files>src/store/workflowStore.ts</files>
  <action>
  1. In executeWorkflow()'s nanoBanana case:
     - Check if node has selectedModel
     - If selectedModel exists and provider !== "gemini", pass API keys in headers:
       ```typescript
       const headers: Record<string, string> = {
         "Content-Type": "application/json"
       };
       if (nodeData.selectedModel?.provider === "replicate") {
         const settings = get().providerSettings;
         const replicateConfig = settings.providers.find(p => p.id === "replicate");
         if (replicateConfig?.apiKey) {
           headers["X-Replicate-API-Key"] = replicateConfig.apiKey;
         }
       }
       // Similar for fal
       ```

  2. Build request payload:
     - Include selectedModel in request body for new providers
     - Keep existing fields for Gemini backward compatibility

  3. Handle response format:
     - Provider generate() returns GenerationOutput with outputs array
     - Extract first image/video output as outputImage
     - For video outputs, store separately (Phase 6 handles video display)

  WHY: The store's execution logic needs to pass provider API keys (stored client-side) to the server route.
  </action>
  <verify>Execute workflow with Gemini model, verify generation still works</verify>
  <done>Workflow execution handles both legacy and new model selection formats</done>
</task>

<task type="auto">
  <name>Task 3: Update GenerateNode to handle legacy data</name>
  <files>src/components/nodes/GenerateNode.tsx</files>
  <action>
  1. When component mounts or data changes:
     - If model exists but not selectedModel, derive selectedModel from model
     - Display the correct provider/model in dropdowns

  2. Ensure UI state reflects actual node data:
     - Provider dropdown shows "gemini" for legacy nodes
     - Model dropdown shows correct Gemini model name

  3. When saving defaults, save in both formats:
     - saveGenerateDefaults should save both model and selectedModel
     - Ensures new nodes get correct defaults

  WHY: The UI must correctly display legacy nodes that were migrated on load.
  </action>
  <verify>Open workflow with old nanoBanana node, verify dropdowns show correct selection</verify>
  <done>GenerateNode displays correct provider/model for both legacy and new nodes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Load existing workflow with nanoBanana nodes - nodes display correctly
- [ ] Execute existing workflow - Gemini generation works
- [ ] Create new Generate node - defaults are correct
- [ ] Save and reload workflow - data persists correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Existing workflows load and execute without errors
- Migration logic populates selectedModel from legacy model field
- Both old and new format nodes work in same workflow
- Phase 3 complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-generate-node-refactor/03-03-SUMMARY.md`
</output>
